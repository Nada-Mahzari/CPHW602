/*
You are given a ROOT file with two trees: sig_filtered (signal events) and bg_filtered (background events). 
The goal is to calculate the efficiency for signal events as a function of the acollinearity threshold (acolin) 
and plot it alongside its 95% Confidence Intervals (CL).

Instructions:
1. Use the following equations for confidence intervals:
   Lower Bound = p - z * sqrt(p * (1 - p) / n)
   Upper Bound = p + z * sqrt(p * (1 - p) / n)
   where:
     - p = efficiency (signal count / total signal events)
     - z = 1.96 (for 95% CL)
     - n = total signal events.

2. Write a ROOT macro or C++ program to:
   - Loop over acollinearity thresholds from 80 to 200.
   - Calculate efficiency and confidence intervals for each threshold.
   - Plot:
       * Efficiency as a blue line with markers.
       * Confidence intervals as dashed lines in a different color.

3. Label the plot:
   - X-axis: Acollinearity threshold (degrees).
   - Y-axis: Efficiency.
   - Include a legend for efficiency and confidence intervals.
*/
#include <TFile.h>
#include <TTree.h>
#include <TCanvas.h>
#include <TGraph.h>
#include <TH1F.h>
#include <TLegend.h>
#include <TMath.h>

void plotEfficiencyWithCI() {
    const int nPoints = 21;  // Number of thresholds to evaluate
    double thresholds[nPoints];
    double efficiencies[nPoints], lowerCI[nPoints], upperCI[nPoints];
    
    // Open the ROOT file and get the trees
    TFile *file = TFile::Open("mlpHiggs.root", "READ");
    TTree *sig_filtered = (TTree *)file->Get("sig_filtered");
    TTree *bg_filtered = (TTree *)file->Get("bg_filtered");

    // Declare the variable for acollinearity
    float acollinearity;  // Declare acollinearity as a float

    // Set the branch address to read 'acolinearity' from the tree
    sig_filtered->SetBranchAddress("acolinearity", &acolinearity);

    // Loop over acollinearity thresholds (from 80 to 200)
    for (int i = 0; i < nPoints; ++i) {
        double threshold = 80.0 + i * 6.0;  // thresholds from 80 to 200 with step of 6
        thresholds[i] = threshold;

        // Calculate the efficiency for signal events
        int signalCount = 0;
        int totalSignal = sig_filtered->GetEntries();

        for (int j = 0; j < totalSignal; ++j) {
            sig_filtered->GetEntry(j);  // Get the data for this entry
            if (acolinearity < threshold) {
                ++signalCount;
            }
        }

        // Efficiency: p = signalCount / totalSignal
        double p = (double)signalCount / totalSignal;
        efficiencies[i] = p;

        // Calculate 95% confidence interval for efficiency
        double z = 1.96;  // z-score for 95% confidence
        double n = totalSignal;
        double lowerBound = p - z * TMath::Sqrt(p * (1 - p) / n);
        double upperBound = p + z * TMath::Sqrt(p * (1 - p) / n);

        lowerCI[i] = lowerBound;
        upperCI[i] = upperBound;
    }

    // Create a canvas for plotting
    TCanvas *canvas = new TCanvas("canvas", "Efficiency and Confidence Intervals", 800, 600);
    
    // Create graphs for efficiency and confidence intervals
    TGraph *gEfficiency = new TGraph(nPoints, thresholds, efficiencies);
    TGraph *gLowerCI = new TGraph(nPoints, thresholds, lowerCI);
    TGraph *gUpperCI = new TGraph(nPoints, thresholds, upperCI);
    
    // Set graph styles
    gEfficiency->SetLineColor(kBlue);
    gEfficiency->SetMarkerStyle(20);  // Blue line with markers
    gEfficiency->SetTitle("Efficiency and 95% Confidence Intervals vs. Acollinearity Threshold");
    gEfficiency->GetXaxis()->SetTitle("Acollinearity Threshold");
    gEfficiency->GetYaxis()->SetTitle("Efficiency");

    gLowerCI->SetLineColor(kRed);  // Red dashed line for lower CI
    gUpperCI->SetLineColor(kRed);  // Red dashed line for upper CI
    gLowerCI->SetLineStyle(2);     // Dashed line
    gUpperCI->SetLineStyle(2);     // Dashed line

    // Draw graphs
    gEfficiency->Draw("ALP");  // 'A' for axis, 'L' for line, 'P' for points
    gLowerCI->Draw("L SAME");  // Same plot for lower CI
    gUpperCI->Draw("L SAME");  // Same plot for upper CI

    // Add a legend
    TLegend *legend = new TLegend(0.7, 0.7, 0.9, 0.9);
    legend->AddEntry(gEfficiency, "Efficiency", "l");
    legend->AddEntry(gLowerCI, "Lower 95% CI", "l");
    legend->AddEntry(gUpperCI, "Upper 95% CI", "l");
    legend->Draw();

    // Save the canvas as a PNG file
    canvas->SaveAs("efficiency_with_ci.png");

    // Close the file
    file->Close();
}
sxs
